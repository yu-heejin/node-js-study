## 기존 multi thread와의 차이점

- 기존의 자바, 닷넷, php 등의 경우 **멀티 스레드 방법으로 클라이언트의 요청을 처리**했다.
    - 즉, **각각의 클라이언트의 요청에 스레드를 할당하여 스레드에서 클라이언트의 요청을 처리하는 방식**을 선택했다
- 하지만, 위와 같은 방법은 다음과 같은 문제가 있다.
    1. 클라이언트의 요청이 증가함에 따라 메모리 사용량 증가(스레드의 수 증가)
    2. 여러개의 스레드를 처리함에 있어서 오버헤드 증가
    3. CPU 유휴 (사용하지 않고 놀게 놔둠)
        1. CPU 유휴의 경우 큰 자원낭비가 될 수 있다.

### CPU 유휴

```jsx
const result = DB.query('select * from user') // 동기작업

// waiting.........

doSomething(result)
```

- 스레드가 cpu를 할당 받으면 DB에서 데이터를 조회하여 doSomething 함수를 실행한다.
    - 그러나 만약, CPU를 할당 받은 시간에 아직 DB에서 값이 조회되지 않았다면 함수를 실행할 수 없다.
    - CPU는 DB에서 조회한 결과 값을 받길 기다리는데, 이는 곧 자원 낭비가 된다.
- 노드는 이러한 낭비되는 CPU를 줄이며, 기존과는 다른 방법으로 접근한다.
    - 클라이언트 요청마다 매번 스레드를 만드는 것이 아니라 **싱글 스레드를 사용하여 각 클라이언트 요청을 처리한다.**
    - 싱글 스레드를 사용하기 때문에 많은 스레드를 사용하는 것보다 메모리를 덜 사용하고, context switching의 빈도수도 적다.
    - 또한, race condition 문제도 덜하다.
    - 단, **싱글 스레드를 사용하기 때문에 시간이 오래 걸리는 작업을 처리하면 다른 클라이언트 요청을 처리할 수 없다.**

## node.js의 싱글 스레드

- 노드는 싱글 스레드지만, 내부적으로는 여러개의 스레드를 사용한다.
- 노드가 **싱글 스레드라는 것은 event loop가 single thread**라는 것을 의미하며, 내부적으로 **여러개의 스레드를 사용하는 것은 libuv의 스레드 풀**을 의미한다.

### 예제

```jsx
...
router.get("/test", function (req, res, next) {
  const start = Date.now();

  while (Date.now() < start + 5000) {}
  res.json({ test: "after 5s" });
  ...
});
```

- /test로 요청을 보내면 5초 후에 응답을 보낸다.
    - n개의 요청을 보냈을 때, 만약 event loop가 정말 싱글 스레드라면 각각의 요청은 이전 요청시간 + 5s 만큼의 시간이 걸릴 것이다.
- 응답 결과
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2cf9aa5f-f2da-4127-b1e2-4c6705773a65/Untitled.png)
    
    - 첫번째 요청은 5초, 두번째 요청은 약 9초가 걸렸다.
    - 만약, **노드가 싱글 스레드가 아니라면 두 개의 요청이 모두 5초가 걸려야한다. (결론적으로 노드는 싱글 스레드가 맞다.)**
- 응답 결과를 보면, event loop를 막아서는 안된다.
    - 즉, 첫번째 요청을 모두 처리한 후 두번째 요청을 처리하기 때문에(싱글 스레드) /test에서 너무 오래걸리는 작업은 하지 말아야 한다.
- 결론적으로 노드는 기존의 방법과는 다른 싱글 스레드를 사용하여 클라이언트 요청을 처리하며, 컨텍스트 스위칭, 메모리 과다사용, race condition, cpu 유휴 처리에서 이점이 있다.

## node.js의 멀티 스레드

- 만약 정말로 /test에서 10초가 걸리는 작업이 있다면 어떡할까?
    - 이를 cpu intensive 한 작업이라고도 한다.
    - node.js 모듈 중 대표적으로 crypto 모듈이 있다.
- **node는 내부적으로 libuv에 thread pool을 가지고 있으며(기본 4개), 시간이 오래 걸리는 작업은 스레드 풀에서 처리하고 있다.**
    - 따라서 cpu intensive한 작업은 스레드 풀에서 처리하기 때문에 모두 같은 시간에 처리될 수 있다!
- 실제로 스레드를 처리하는 것은 CPU, 물리 코어이기 때문에 스레드 수를 늘리면 그만큼 context switching이 늘어나기 때문에 **보통 물리코어 수만큼 스레드 풀 크기를 설정하도록 권장한다.**

## libuv

- node는 크게 V8과 libuv로 구성되어 있다.
    - V8은 자바스크립트 코드를 파싱하고 실행하는 자바스크립트 엔진이다.
    - libuv는 자바스크립트가 파일을 읽고, 쓰고, 삭제하고 network I/O, 이벤트 루프, 스레드 풀 등의 기능을 제공한다.
- **libuv는 기본적으로 커널에서 지원하는 비동기 작업을 알고 있기 때문**에 node.js에서 파일, DB, I/O 작업, 네트워크 I/O를 수행하게 되면 해당 작업은 커널 API를 사용하여 처리된다.
    - 이후 작업이 완료되면 해당 이벤트가 이벤트 루프의 phase에 들어가 처리된다.
- 커널 API를 사용하지 못하는 경우 thread pool로 넘기게 된다.
    - 대표적으로 crypto 모듈의 경우 cpu intensive한 작업이기 때문에 이벤트 루프에서 실행되면 안되며, 스레드 풀에서 처리된다.
    - 반대로 http 모듈을 사용하는 network I/O의 경우 커널 API를 사용하기 때문에 http 요청을 할 때마다 바로 처리된다.
- libuv는 또한 이벤트 루프를 지원한다.
    - 이벤트 루프는 메인 스레드로, 우리가 작성한 라우터 코드, if 분기, 콜백 모두 이벤트 루프에서 실행된다.
    - 특정 작업에 대해 커널 API를 사용할 지 아니면 스레드 풀에게 처리를 맡길지 결정한다.
    - 스레드 풀이나 커널 API가 완료된 작업에 대한 이벤트를 이벤트 루프에서 실행하게 한다.
- 아래 사진에서 각각의 Run due timer ~ Call close callbacks를 phase라고 하며, 이벤트 루프는 페이즈의 이벤트를 계속 실행하는 역할을 한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ab9031e-27f2-4808-bfba-8b9e2d426115/Untitled.png)
    

## 참고 자료

- [https://kosaf04pyh.tistory.com/340](https://kosaf04pyh.tistory.com/340)