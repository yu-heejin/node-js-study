## 서버

- 노드는 서버 애플리케이션을 실행하는 데 가장 많이 사용한다.
- 서버란 **네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램**을 의미한다.
- 반대로 클라이언트는 **요청을 보내는 주체**로, 브라우저, 데스크톱 프로그램, 모바일 앱 등 다양하다.
- 웹이나 앱을 사용할 때는 나의 데이터(아이디, 비번, 이메일 등)와 서비스의 데이터가 생성된다.
    - 이 데이터를 어딘가에 저장하고, 그 어딘가에서 클라이언트로 데이터를 받아와야 하는데, 이 곳이 바로 서버이다.
- 서버라고 할지라도 요청에 대한 응답만 하는 것은 아니며, 다른 서버에 요청을 보낼 수도 있다.
    - 이 경우 **요청을 보낸 서버가 클라이언트 역할을 한다.**
- 서버는 클라이언트의 요청에 대해 응답해야 한다.
    - 응답으로 항상 YES를 하는 것은 아니며, NO를 보낼 수도 있다.

### 서버 동작 과정(웹)

1. 주소창에 길벗출판사의 웹 사이트 주소를 입력 **(요청)**
2. 브라우저는 그 주소에 해당하는 길벗출판사의 컴퓨터 위치를 확인한다.
3. 해당 컴퓨터로부터 길벗출판사의 웹 사이트 페이지를 받아와 요청자의 브라우저(클라이언트)에 띄운다 **(응답)**

### 서버 동작 과정(앱)

1. 구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누른다. **(요청)**
2. 내려받기**(응답)**가 실행된다.
    1. 앱 설치 파일은 구글과 애플의 서버에 저장되어 있기 때문에 그곳에서 데이터를 받아와 모바일 기기에 설치할 수 있다.
    2. 플레이 스토어와 앱스토어는 클라이언트 역할을 하는 것

## 자바스크립트 런타임

- 노드는 자바스크립트 런타임이다.
    - **런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 의미한다.**
    - 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있다.
- 기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행할 수 있었다.
    - 브라우저는 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있다.
    - 브라우저 외의 환경에서 자바스크립트를 실행하기 위한 다양한 시도가 있었으나 자바스크립트의 실행 속도 문제 때문에 각광받지 못했다.
- 2008년 구글이 V8 엔진을 사용해 크롬을 출시하면서, 2009년 V8 엔진 기반의 노드 프로젝트를 시작했다.

### 노드 내부 구조

- 노드는 V8과 더불어 libuv라는 라이브러리를 사용한다.
- V8과 libuv는 C와 C++로 구현되어 있다.
- libuv 라이브러리는 노드의 특성인 **이벤트 기반, 논블로킹 I/O 모델**을 구현하고 있다.

## 이벤트 기반

- 이벤트 기반(event-driven)이란 **이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식**을 의미한다.
    - 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있다.
- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할 지 미리 등록해야 한다.
    - 이를 **이벤트 리스너(event listener)에 콜백(callback) 함수를 등록한다고 표현한다.**
    - 버튼 클릭을 예로 들면, 클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수를 등록해두면 클릭 이벤트가 발생할 때마다 콜백 함수가 실행돼 경고창이 뜬다.
- **노드는 이벤트 기반 방식으로 동작**하므로, 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출한다.
    - 발생한 이벤트가 없거나 발생했던 이벤트를 모두 처리하면, 노드는 다음 이벤트가 발생할 때까지 대기한다.
- 이벤트 기반 모델에서는 이벤트 루프(event loop)라는 개념이 등장한다.
    - 여러 이벤트가 동시에 발생하면, 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다.
- 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행한다.
    - 함수 호출 부분을 발견하면 호출한 함수를 호출 스택(call stack)에 넣는다.

### 이벤트 기반 동작 과정

1. 이벤트 리스너에 콜백 함수를 등록한다.
2. 시스템에서 이벤트가 발생한다.
3. 이벤트가 발생하면 등록된 콜백 함수를 호출한다.

### 예제 코드

```jsx
function first() {
	second();
	console.log('첫 번째');
}

function second() {
	third();
	console.log('두 번째');
}

function third() {
	console.log('세 번째');
}

first();

// 실행 결과: 세 번째 → 두 번째 → 첫 번째
```

- 실행 결과는 세 번째 → 두 번째 → 첫 번째
- 함수는 스택을 사용하기 때문이다.

```jsx
function run() {
	console.log('3초 후 실행');
}

console.log('시작');
setTimeout(run, 3000);
console.log('끝');

/**
	실행 결과:
	
	시작
	끝
	3초 후 실행
**/
```

- 특정 밀리초(1,000분의 1초) 이후에 코드를 실행하는 setTimeout을 사용한 코드이다.
- 실행 과정은 다음과 같다.
    1. 먼저 전역 콘텍스트인 anonymous가 호출 스택에 들어간다.
    2. 그 후 setTimeout이 호출 스택에 들어간다.
        1. 호출 스택에 들어간 순서와 반대로 실행되므로, setTimeout이 먼저 실행된다.
    3. **setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고, setTimeout은 호출 스택에서 빠진다.**
    4. 그 후 anonymous가 호출 스택에서 빠진다.
    5. 백그라운드에서는 3초를 센 후 run함수를 테스트 큐로 보낸다.
        1. 3초를 세었다는 것은 백그라운드에 맡겨진 작업이 완료되었음을 의미한다.
        2. 이벤트 루프는 호출 스택이 비어 있으면 테스크 큐에서 하나씩 함수를 가져와 호출 스택에 넣고 실행한다.
    6. 호출 스택 실행이 끝나 호출 스택이 비어있으면 이벤트 루프가 테스트 큐의 콜백을 호출 스택으로 올린다.
    7. 이벤트 루프가 run 콜백을 테스크 큐에서 꺼내 호출 스택으로 올리면, 올려진 run은 실행되고, 실행 완료 후 호출 스택에서 제거된다.
        1. 이벤트 루프는 테스크 큐에 콜백 함수가 들어올 때까지 계속 대기한다.
- 만약 호출 스택에 함수가 너무 많이 들어있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수 있다.
    - **이벤트 루프는 호출 스택이 비어있을 때만 태스크 큐에 있는 run 함수를 호출 스택으로 가져오기 때문이다.**
    - 이것이 setTimeout이 정확하지 않을 수도 있는 이유이다.

### 호출 스택

- 그림 1-5의 **anonymous 함수**는 처음 실행 시의 전역 콘텍스트(global context)를 의미한다.
    - 콘텍스트는 함수가 호출되었을 때 생성되는 환경을 의미한다.
    - **자바스크립트 코드는 실행 시 기본적으로 전역 콘텍스트 안에서 돌아간다고 생각하면 좋다.**
- 함수는 실행되는 동안 호출 스택에 머물러 있다가 실행이 완료되면 호출 스택에서 지워진다.

### 이벤트 루프

- 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다.
- 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하기 때문에 loop라고 부른다.

### 백그라운드

- setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳
- 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라도 봐도 무방하다.
- 여러 작업이 동시에 실행될 수 있다.

### 태스크 큐

- 이벤트 발생 후, 백그라운드에서는 테스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다.
- 백그라운드에서 처리된 작업의 콜백 함수가 콜 스택으로 가기 전까지 대기하는 FIFO형 자료구조
    - [https://velog.io/@m-dzn/Node-태스크-큐](https://velog.io/@m-dzn/Node-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90)
- 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 한다.
- 콜백들은 보통 완료된 순서대로 줄을 서 있지만, 특정한 경우 순서가 바뀌기도 한다.
- 태스크 큐는 실제로 여러 개의 큐로 이루어져 있다.
- 이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부른다.

## 논블로킹 I/O

- 이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다.
- 작업에는 두 가지 종류가 있다.
    - 동시에 실행될 수 있는 작업
    - 동시에 실행될 수 없는 작업
- 기본적으로 자바스크립트 코드는 동시에 실행될 수 없다.
    - 하지만 자바스크립트 상에서 돌아가는 것이 아닌 I/O 작업같은 것은 동시에 처리될 수 있다.
- I/O란 입력/출력을 의미한다.
    - 파일 시스템 접근이나 네트워크를 통한 요청같은 작업이 I/O의 일종이다.
    - 이러한 작업을 할 때 **노드는 논블로킹 방식으로 처리하는 방법을 제공한다.**
- **논블로킹(non-blocking)이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것을 의미한다.**
    - 반대로, 블로킹(blocking)은 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다.
- 노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 한다.
    - 따라서 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다.
    - 작업 순서에 따라 큰 성능 차이가 나기 때문에, 동시에 처리될 수 있는 I/O 작업일지라도 논블로킹 방식으로 코딩하지 않으면 의미가 퇴색되므로, 논블로킹 방식으로 코딩하는 습관을 들여야 한다.
- 다만, 논블로킹 방식으로 코드를 작성하더라도 코드가 모두 자신이 직접 작성한 것이라면 전체 소요 시간이 짧아지지는 않는다.
    - 코드는 서로 동시에 실행되지 않기 때문이며, 단순히 실행 순서만 바뀐다.
- 하지만 I/O 작업이 없다고 해서 논블로킹이 의미가 없는 것은 아니다.
    - 오래 걸리는 작업을 처리해야하는 경우, 논블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기해야 하는 상황을 막을 수 있다.
    - 또한, **논블로킹과 동시가 같은 의미가 아니라는 사실을 알아야 한다.**
        - 동시성은 동시 처리가 가능한 작업을 논블로킹 처리해야 얻을 수 있다.

### 예제

```jsx
function longRunningTask() {
	// 오래 걸리는 작업
	console.log('작업 끝!');
}

console.log('시작');
longRunningTask();
console.log('다음 작업');

/*
	실행 결과

	시작
	작업 끝
	다음 작업
*/
```

- 작업을 수행하는데 오래 걸리는 longRunningTask 함수가 있고, 이 함수가 블로킹 방식의 I/O 작업을 한다고 생각해보자.
    - 이 작업이 완료되기 전까지는 이어지는 console.log(’다음 작업’)이 호출되지 않는다.
- setTimeout을 사용해 코드를 바꿔보자.
    
    ```jsx
    function longRunningTask() {
    	// 오래 걸리는 작업
    	console.log('작업 끝!');
    }
    
    console.log('시작');
    setTimeout(longRunningTask, 0);
    console.log('다음 작업');
    
    /*
    	실행 결과
    
    	시작
    	다음 작업
    	작업 끝
    */
    ```
    
    - setTimeout(콜백, 0)은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나이다.
        - 이벤트 루프를 이해했다면, setTimeout의 콜백 함수인 longRunningTask가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있다.
        - 다음 작업이 먼저 실행된 후 오래 걸리는 작업이 완료된다.
    - 밀리초를 0으로 설정했으므로 바로 실행된다고 착각할 수 있지만, 브라우저와 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않는다.
        - html 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있다.

## 싱글 스레드

- 싱글 스레드란 스레드가 하나뿐이라는 것을 의미한다.
- 자바스크립트 코드가 동시에 실행될 수 없는 이유이기도 하다.
- **노드는 엄밀히 말하자면 싱글 스레드로 동작하지 않는다.**
    - 노드를 실행하면 먼저 프로세스 하나가 생성된다.
    - 그 후 그 프로세스에서 스레드들을 생성하는데, 이 때 **내부적으로 스레드를 여러 개 생성한다.**
    - 그 중에서 **우리가 직접 제어할 수 있는 스레드는 하나뿐**이다! → 노드가 싱글 스레드라고 여겨지는 이유
- 스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 하나의 스레드만 직접 조작할 수 있으므로 일손이 하나인 셈이다.
    - 요청이 많이 들어오면 한 번에 하나씩 요청을 처리한다.
    - 블로킹이 심하게 일어나는 작업을 처리하지만 않으면 스레드 하나로도 충분하다.
    - 블로킹이 발생할 것 같은 경우 논블로킹 방법으로 대기 시간을 최대한 줄인다.
- 멀티 스레드 방식에서는 손님이 한 명 올 때마다 점원도 한 명 붙어 주문을 받고 서빙을 한다.
    - 손님 한 명당 점원도 한명이면 서빙 자체는 문제가 없다. 점원 한명에게 문제가 생가면 다른 점원으로 대체하면 된다.
    - 하지만 손님 수가 줄었을 때 일을 하지않고 노는 직원이 있을 수 있고, 점원을 새로 고용하거나 직원을 해고하는데 비용이 발생하기도 한다.
- 멀티 스레드에 논블로킹 방식을 사용하면 실제로 더 좋다.
    - 다만, 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어렵기 때문에 **멀티 프로세싱 방식을 대신 사용한다.**
    - I/O 요청에는 멀티 프로세싱이 더 효율적이기도 하다.

### 싱글 스레드 예시

- 한 음식점에 점원 1명, 손님 여러 명이 존재한다고 가정하자.
- 싱글 스레드(점원), 블로킹 모델 - 비효율적
    - 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 한다. 그 후 다음 손님의 주문을 받는다.
    - 이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 하지 못하고 기다리고 있어야 한다.
- **싱글 스레드, 논블로킹 모델 - 노드가 채택하는 방식**
    - 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받는다.
    - 요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 사실만 주방에 계속 알려준다.
    - 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙한다.
    - 요리의 특성(블로킹, 논블로킹)에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서가 일치하지 않을 수도 있다.
    - 점원은 한 명이지만, 혼자서 많은 일을 처리할 수 있으나, 점원이 아프면 문제가 생길 수 있다.
    - 또한, 요리를 하는데 시간이 오래 걸린다면(CPU를 많이 쓴다면) 주문이 많이 들어왔을 때 버거울 수 있다.

### 스레드 풀과 워커 스레드

- 노드가 싱글 스레드로 동작하지 않는 두 가지 경우가 있는데, 스레드 풀(Thread Pool)과 워커 스레드(Worker Thread)이다.
- 스레드 풀은 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용한다.
    - 대표적으로 암호화, 파일 입출력, 압축 등이 있다.
- 워커 스레드는 노드 12버전에서 안정화된 기능으로, 노드에서도 멀티 스레드를 사용할 수 있다.
    - 우리가 직접 다수의 스레드를 다룰 수 있으며, CPU 작업(연산이 많은 작업)이 많은 경우 워커 스레드를 사용하면 된다.

### 멀티 스레딩과 멀티 프로세싱 비교

| 멀티 스레딩 | 멀티 프로세싱 |
| --- | --- |
| 하나의 프로세스 안에서 여러 개의 스레드 사용 | 여러 개의 프로세스 사용 |
| CPU 작업이 많이 사용될 때 사용 | I/O 요청이 많을 때 사용 |
| 프로그래밍이 어려움 | 비교적 쉬움 |
- I/O 작업을 처리할 땐 멀티 스레딩보다는 멀티 프로세싱이 효율적이므로, 노드는 멀티 프로세싱을 많이 한다.